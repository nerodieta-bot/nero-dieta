{
  "entities": {
    "Ingredient": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Ingredient",
      "type": "object",
      "description": "Represents an ingredient in the dog food database.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ingredient."
        },
        "name": {
          "type": "string",
          "description": "Name of the ingredient."
        },
        "status": {
          "type": "string",
          "description": "Safety status of the ingredient (safe, warning, danger)."
        },
        "category": {
          "type": "string",
          "description": "Category of the ingredient (e.g., protein, vegetable, grain)."
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the ingredient and its effects on dogs."
        },
        "nero": {
          "type": "string",
          "description": "Nero's comments about the ingredient."
        },
        "toxicity": {
          "type": "string",
          "description": "Toxicity level of the ingredient, like 'śmiertelne' or 'silnie toksyczne'."
        },
        "klinikaInfo": {
          "type": "string",
          "description": "Information about the ingredient from the clinics, like 'Zgodnie z zaleceniami...'"
        }
      },
      "required": [
        "id",
        "name",
        "status",
        "category",
        "description"
      ]
    },
    "MealPlan": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MealPlan",
      "type": "object",
      "description": "Represents a meal plan for a dog, composed of several ingredients.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the meal plan."
        },
        "name": {
          "type": "string",
          "description": "Name of the meal plan."
        },
        "ingredientIds": {
          "type": "array",
          "description": "References to Ingredients. (Relationship: MealPlan 1:N Ingredient)",
          "items": {
            "type": "string"
          }
        },
        "description": {
          "type": "string",
          "description": "Description of the meal plan, including its benefits."
        }
      },
      "required": [
        "id",
        "name",
        "ingredientIds",
        "description"
      ]
    },
    "UserContribution": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserContribution",
      "type": "object",
      "description": "Represents a user submission for a new ingredient or an update to an existing one.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the contribution."
        },
        "ingredientId": {
          "type": "string",
          "description": "Reference to Ingredient. (Relationship: UserContribution 1:1 Ingredient).  If null, this is a new ingredient submission."
        },
        "userId": {
          "type": "string",
          "description": "Reference to UserProfile. (Relationship: UserProfile 1:N UserContribution)"
        },
        "submissionDate": {
          "type": "string",
          "description": "Date and time when the contribution was submitted.",
          "format": "date-time"
        },
        "status": {
          "type": "string",
          "description": "Status of the contribution (pending, approved, rejected)."
        },
        "data": {
          "type": "string",
          "description": "JSON string containing the suggested data"
        }
      },
      "required": [
        "id",
        "userId",
        "submissionDate",
        "status",
        "data"
      ]
    },
    "UserProfile": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UserProfile",
      "type": "object",
      "description": "Represents a user profile in the application.",
      "properties": {
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "ownerName": {
          "type": "string",
          "description": "Display name of the user."
        },
        "dogName": {
          "type": "string",
          "description": "Name of the user's dog."
        },
        "mealPlanGenerations": {
          "type": "number",
          "description": "The number of times the user has generated a meal plan."
        },
        "ingredientViewCount": {
          "type": "number",
          "description": "The number of times the user has viewed an ingredient detail page."
        }
      },
      "required": [
        "email"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "google.com",
      "phone"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "UserProfile",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "Stores user profile information. Accessible only to the user and admins.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/ingredients/{ingredientId}",
        "definition": {
          "entityName": "Ingredient",
          "schema": {
            "$ref": "#/backend/entities/Ingredient"
          },
          "description": "Stores ingredient data. Publicly readable, but editable only by admins.",
          "params": [
            {
              "name": "ingredientId",
              "description": "The unique identifier of the ingredient."
            }
          ]
        }
      },
      {
        "path": "/meal_plans/{mealPlanId}",
        "definition": {
          "entityName": "MealPlan",
          "schema": {
            "$ref": "#/backend/entities/MealPlan"
          },
          "description": "Stores meal plans. Publicly readable, but editable only by admins.",
          "params": [
            {
              "name": "mealPlanId",
              "description": "The unique identifier of the meal plan."
            }
          ]
        }
      },
      {
        "path": "/user_contributions/{contributionId}",
        "definition": {
          "entityName": "UserContribution",
          "schema": {
            "$ref": "#/backend/entities/UserContribution"
          },
          "description": "Stores user submissions for new ingredients or updates. Includes 'userId' and is readable by submitting user and admins.",
          "params": [
            {
              "name": "contributionId",
              "description": "The unique identifier of the user contribution."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "user",
          "schema": {
            "$ref": "#/backend/entities/UserProfile"
          },
          "description": "DBAC (Database Access Control) via explicit admin role assignment. Existence determines admin status.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      }
    ],
    "reasoning": "This Firestore structure prioritizes security, scalability, and ease of debugging by adhering to the core design principles and strategy mandates outlined. It focuses on authorization independence and structural segregation.  \n\n**Authorization Independence:** Authorization Independence is achieved by avoiding hierarchical authorization dependencies (`get()`). Roles and access control lists are stored directly within documents or in dedicated collections, eliminating the need to traverse the data hierarchy for authorization checks.  For instance, the `members` map in collaborative documents stores the roles of users, enabling direct access validation.\n\n**Structural Segregation:** Ensures that each collection contains documents with a uniform security posture.  This simplifies security rules by eliminating the need for complex logic to handle varied access requirements within the same collection.\n\n**QAPs (Rules Are Not Filters):** The structure enables secure list operations by preventing the need to filter based on data content within rules. Path-based ownership and membership maps facilitate direct authorization based on the document path or explicitly defined roles, ensuring that list operations only return authorized documents.\n\n**Explanation of the Structure:**\n\n*   `/users/{userId}`: Stores user profile information, accessible only to the user and admins.\n*   `/ingredients/{ingredientId}`: Stores ingredient data, publicly readable but editable only by admins. Segregating the `/ingredients` collection ensures consistent security posture.\n*   `/meal_plans/{mealPlanId}`: Stores meal plans, publicly readable but editable only by admins.\n*   `/user_contributions/{contributionId}`: Stores user submissions for new ingredients or updates.  Each submission includes the `userId` and is readable by the submitting user and admins.\n*   `/roles_admin/{userId}`:  DBAC (Database Acess Control) via explicit admin role assignment. If a document exists, then the user is an admin."
  }
}
